// Application modules
const { ParseOptions } = require(`./rfc2132`),
    { Trace, Debug } = require(`../logging`);

let _offset = new WeakMap(),
    _operation = new WeakMap(),
    _originalMessage = new WeakMap(),
    _remoteAddressInformation = new WeakMap();

class DHCP {
    constructor(msg, rinfo) {
        _originalMessage.set(this, msg);
        _remoteAddressInformation.set(this, rinfo);

        Trace({
            [`Remote address information`]: this.remoteAddress,
            [`Hexadecimal message`]: this.message.toString(`hex`)
        });

        this._generateOperation();

        Debug({ [`Decoded operation`]: this.operation });
    }

    get message() { return _originalMessage.get(this); }
    get operation() { return _operation.get(this); }
    get remoteAddress() { return _remoteAddressInformation.get(this); }

    _generateOperation() {
        // The offset must be incremented for each read, but the read takes place at the pre-op offset
        _offset.set(this, 0);

        // Request or reply
        let op = this._readUInt8(),
            // Hardware address type (1 for ethernet)
            htype = this._readUInt8(),
            // Hardware address length (for identifier [MAC address for ethernet])
            hlen = this._readUInt8(),
            // Number of hops for BOOTP message (0 for direct from client)
            hops = this._readUInt8(),
            // Unique identifier generated by client
            xid = this._readUInt32(),
            secs = this._readUInt16(),
            flags = this._readUInt16(),
            ciaddr = this._readIpAddress(),
            yiaddr = this._readIpAddress(),
            siaddr = this._readIpAddress(),
            giaddr = this._readIpAddress(),
            chaddr = this._readHardwareAddress(htype, hlen),
            sname = this._readString(64),
            file = this._readString(128),
            // Magic cookie is defined in the RFC for beginning the options field, and is always 99, 130, 83 and 99
            magicCookie = this._readUInt32(),
            options = ParseOptions(this, _offset)
            ;

        _operation.set(this,{
            op,
            htype,
            hlen,
            hops,
            xid,
            secs,
            flags,
            ciaddr,
            yiaddr,
            siaddr,
            giaddr,
            chaddr,
            sname,
            file,
            magicCookie,
            options,
        });
    }

    _readString(lengthInOctets, format = `utf8`) {
        let offset = _offset.get(this);

        let data = this.message.toString(format, offset, offset + lengthInOctets).replace(/\0/g, ``);

        _offset.set(this, offset + lengthInOctets);

        return (data.length > 0) ? data : null;
    }

    _readUInt8() {
        let data = this.message.readUInt8(_offset.get(this));
        _offset.set(this, _offset.get(this) + 1);
        return data;
    }

    _readUInt16() {
        let data = this.message.readUInt16BE(_offset.get(this));
        _offset.set(this, _offset.get(this) + 2);
        return data;
    }

    _readUInt32() {
        let data = this.message.readUInt32BE(_offset.get(this));
        _offset.set(this, _offset.get(this) + 4);
        return data;
    }

    _readIpAddress() {
        let ip = [this._readUInt8(), this._readUInt8(), this._readUInt8(), this._readUInt8()];
        return ip.join(`.`);
    }

    _readHardwareAddress(type, lengthInOctets) {
        let offset = _offset.get(this);
        let address = this.message.toString(`hex`, offset, offset + lengthInOctets);

        // This is hardcoded to expect MAC addresses
        switch (type) {
            case 1:
                {
                    let newAddress = [],
                        idx = 0;

                    while (idx < address.length) {
                        newAddress.push(address[idx] + address[idx + 1]);
                        idx += 2;
                    }

                    address = newAddress.join(`:`);
                }
                break;

            default:
                throw new Error(`Expected hardware address type of 1, but received ${type}`);
        }

        // The hardware address slot is 16 octets long
        _offset.set(this, offset + 16);

        return address;
    }
}

module.exports.DhcpStack = DHCP;
