// Application modules
const { DHCPOptions, ParseOptions, EncodeOptions, EnsureClientIdentifier } = require(`./rfc2132`),
    { MACAddressFromHex, HexFromMACAddress,
        ReadIpAddress, ReadString, ReadUInt8, ReadUInt16, ReadUInt32,
        WriteIpAddress, WriteString, WriteUInt8, WriteUInt16, WriteUInt32 } = require(`../utilities`),
    { Trace } = require(`../logging`);

let _bufferMessage = new WeakMap();

let _op = new WeakMap(),
    _htype = new WeakMap(),
    _hlen = new WeakMap(),
    _hops = new WeakMap(),
    _xid = new WeakMap(),
    _secs = new WeakMap(),
    _flags = new WeakMap(),
    _ciaddr = new WeakMap(),
    _yiaddr = new WeakMap(),
    _siaddr = new WeakMap(),
    _giaddr = new WeakMap(),
    _chaddr = new WeakMap(),
    _sname = new WeakMap(),
    _file = new WeakMap(),
    _magicCookie = new WeakMap(),
    _options = new WeakMap();

const BOOTREQUEST = 1,
    BOOTREPLY = 2,
    MAGIC_COOKIE = [99, 130, 83, 99];

class Message {
    constructor() {}

    // Request or reply
    set isReply(val) { this.op = val ? BOOTREPLY : BOOTREQUEST; }
    get op() { return _op.get(this); }
    set op(val) { _op.set(this, val); }

    // Hardware address type (1 for ethernet)
    get htype() { return _htype.get(this); }
    set htype(val) { _htype.set(this, val); }

    // Hardware address length (for identifier [MAC address for ethernet])
    get hlen() { return _hlen.get(this); }
    set hlen(val) { _hlen.set(this, val); }

    // Number of hops for BOOTP message (0 for direct from client)
    get hops() { return _hops.get(this); }
    set hops(val) { _hops.set(this, val); }

    // Unique identifier generated by client
    get xid() { return _xid.get(this); }
    set xid(val) { _xid.set(this, val); }

    // Client-generated seconds elapsed since client began address acquisition or renewal process
    get secs() { return _secs.get(this); }
    set secs(val) { _secs.set(this, val); }

    // Broadcast flag, most of which is reserved for future usage
    get flags() { return _flags.get(this); }
    set flags(val) { _flags.set(this, val); }

    // Client existing IP - Only non-zero for clients in BOUND/RENEW/REBINDING state
    get ciaddr() { return _ciaddr.get(this); }
    set ciaddr(val) { _ciaddr.set(this, val); }

    // [Y]our (server-assigned to client) IP address
    get yiaddr() { return _yiaddr.get(this); }
    set yiaddr(val) { _yiaddr.set(this, val); }

    // IP of the next server to use, in DHCPOFFER and DHCPACK
    get siaddr() { return _siaddr.get(this); }
    set siaddr(val) { _siaddr.set(this, val); }

    // Relay agent IP address (Used for booting via a relay)
    get giaddr() { return _giaddr.get(this); }
    set giaddr(val) { _giaddr.set(this, val); }

    // Client hardware address (e.g. Ethernet MAC)
    get chaddr() { return _chaddr.get(this); }
    set chaddr(val) { _chaddr.set(this, val); }

    // Server host name (optional)
    get sname() { return _sname.get(this); }
    set sname(val) { _sname.set(this, val); }

    // Boot file name: "generic" or null in DHCPDISCOVER; fully qualified directory-path in DHCPOFFER
    get file() { return _file.get(this); }
    set file(val) { _file.set(this, val); }

    // Magic cookie is defined in the RFC for beginning the options field
    // It is always 99, 130, 83 and 99
    // This formalizes the options as DHCP as opposed to underlying BOOTP vendor codes
    get isDhcpMessage() {
        let isDhcp = true;
        MAGIC_COOKIE.forEach((value, idx) => {
            if (!!this.magicCookie && (value !== this.magicCookie[idx]))
                isDhcp = false;
        });

        return isDhcp && !!this.magicCookie && (this.magicCookie.length == MAGIC_COOKIE.length);
    }
    get magicCookie() { return _magicCookie.get(this); }
    set magicCookie(val) { _magicCookie.set(this, val); }

    // DHCP Options
    get options() { return _options.get(this); }
    set options(val) { _options.set(this, val); }

    // Message as a buffer
    get binaryMessage() { return _bufferMessage.get(this); }

    _readHardwareAddress(buf, offset, type, lengthInOctets) {
        let address;
        // The hardware address slot is 16 octets long
        ({ value: address, offset } = ReadString(buf, offset, 16, `hex`));

        // This is hardcoded to expect MAC addresses
        switch (type) {
            case 1:
                address = MACAddressFromHex(address.substr(0, lengthInOctets * 2));
                break;

            default:
                throw new Error(`Expected hardware address type of 1, but received ${type}`);
        }

        return { value: address, offset };
    }
    _writeHardwareAddress(buf, data, offset, lengthInOctets) {
        let hexAddress = HexFromMACAddress(data);

        offset = WriteString(buf, hexAddress, offset, 16, `hex`);

        return offset;
    }
    _readMagicCookie(buf, offset) {
        let vendorIdCookie = [];
        for (let idx = 0; idx < 4; idx++) {
            let value;
            ({ value, offset } = ReadUInt8(buf, offset));
            vendorIdCookie.push(value);
        }

        return { value: vendorIdCookie, offset };
    }
    _writeMagicCookie(buf, offset) {
        this.magicCookie = MAGIC_COOKIE;
        MAGIC_COOKIE.forEach(value => {
            offset = WriteUInt8(buf, value, offset);
        });
        return offset;
    }

    Decode(messageBuffer) {
        // Specify an offset object that will be automatically adjusted by the read functions
        let offset = 0;

        ({ value: this.op, offset } = ReadUInt8(messageBuffer, offset));
        ({ value: this.htype, offset } = ReadUInt8(messageBuffer, offset));
        ({ value: this.hlen, offset } = ReadUInt8(messageBuffer, offset));
        ({ value: this.hops, offset } = ReadUInt8(messageBuffer, offset));
        ({ value: this.xid, offset } = ReadUInt32(messageBuffer, offset));
        ({ value: this.secs, offset } = ReadUInt16(messageBuffer, offset));
        ({ value: this.flags, offset } = ReadUInt16(messageBuffer, offset));
        ({ value: this.ciaddr, offset } = ReadIpAddress(messageBuffer, offset));
        ({ value: this.yiaddr, offset } = ReadIpAddress(messageBuffer, offset));
        ({ value: this.siaddr, offset } = ReadIpAddress(messageBuffer, offset));
        ({ value: this.giaddr, offset } = ReadIpAddress(messageBuffer, offset));
        ({ value: this.chaddr, offset } = this._readHardwareAddress(messageBuffer, offset, this.htype, this.hlen));
        ({ value: this.sname, offset } = ReadString(messageBuffer, offset, 64));
        ({ value: this.file, offset } = ReadString(messageBuffer, offset, 128));
        ({ value: this.magicCookie, offset } = this._readMagicCookie(messageBuffer, offset));

        // As options are the last component of a message, we don't need the offset back
        this.options = ParseOptions(messageBuffer, offset);

        // If the client did not include a clientIdentifier field in the options, generate one
        EnsureClientIdentifier(this);
    }

    Encode() {
        let offset = 0;

        // Create a sufficiently large buffer
        let encodedMessage = Buffer.alloc(2000);

        offset = WriteUInt8(encodedMessage, this.op, offset);
        offset = WriteUInt8(encodedMessage, this.htype, offset);
        offset = WriteUInt8(encodedMessage, this.hlen, offset);
        offset = WriteUInt8(encodedMessage, this.hops, offset);
        offset = WriteUInt32(encodedMessage, this.xid, offset);
        offset = WriteUInt16(encodedMessage, this.secs, offset);
        offset = WriteUInt16(encodedMessage, this.flags, offset);
        offset = WriteIpAddress(encodedMessage, this.ciaddr, offset);
        offset = WriteIpAddress(encodedMessage, this.yiaddr, offset);
        offset = WriteIpAddress(encodedMessage, this.siaddr, offset);
        offset = WriteIpAddress(encodedMessage, this.giaddr, offset);
        offset = this._writeHardwareAddress(encodedMessage, this.chaddr, offset, this.hlen);
        offset = WriteString(encodedMessage, this.sname, offset, 64);
        offset = WriteString(encodedMessage, this.file, offset, 128);
        offset = this._writeMagicCookie(encodedMessage, offset);

        // As options are the last component of a message, we don't need the offset back
        EncodeOptions(encodedMessage, this.options, offset);

        // Start at the back of the buffer, and step forward until the first data octet
        let lastData = 0;
        for (let idx = encodedMessage.length - 1; idx >= 0; idx--)
            if (encodedMessage[idx] !== 0x00) {
                lastData = idx;
                break;
            }

        _bufferMessage.set(this, encodedMessage.slice(0, lastData + 2));
    }

    GenerateReply(requestMessage, assignedAddress, configuration) {
        this.isReply = true;
        this.htype = requestMessage.htype;
        this.hlen = requestMessage.hlen;
        this.hops = requestMessage.hops;
        this.xid = requestMessage.xid;
        this.secs = requestMessage.secs;
        this.flags = requestMessage.flags;
        this.ciaddr = `0.0.0.0`;
        this.yiaddr = assignedAddress.ipAddress;
        this.siaddr = configuration.serverIpAddress || `0.0.0.0`; // This server's IP
        // Ignore relays for now
        this.giaddr = `0.0.0.0`;
        this.chaddr = requestMessage.chaddr;
        // Don't provide a hostname for this server
        this.sname = null;
        // Don't provide a boot file path
        this.file = null;

        // Specify the parameters the server will include as part of the response
        let serverDefinedParameters = [
            `dhcpMessageType`,
            `serverIdentifier`,
            `ipAddressLeaseTime`,
            `renewalTimeValue`,
            `rebindingTimeValue`
        ];

        // Convert to a list of codes
        let parameters = serverDefinedParameters.map(propertyName => { Trace(propertyName, `dhcp`); return DHCPOptions.byProperty[propertyName].code; });

        // Supply the requested parameters
        requestMessage.options.parameterRequestList.forEach(param => {
            if (parameters.indexOf(param.code) < 0)
                parameters.push(param.code);
        });

        let options = {};

        parameters.forEach(code => {
            let dhcpOption = DHCPOptions.byCode[code],
                value = undefined;

            switch (dhcpOption.propertyName) {
                case `broadcastAddressOption`: {
                    // Value is the last address in the subnet for the client's IP
                    let mask = configuration.dhcp.leases.pool.networkMask.split(`.`),
                        address = assignedAddress.ipAddress.split(`.`).map((octet, idx) => { return +mask[idx] == 255 ? octet : 255; });
                    value = address.join(`.`);
                }
                    break;
                case `dhcpMessageType`:
                    value = null;
                    break;
                case `domainName`:
                    value = configuration.dns.domain;
                    break;
                case `domainNameServerOption`:
                    value = configuration.dns.servers.map(ip => { return (ip == `primaryIP`) ? configuration.serverIpAddress : ip; });
                    break;
                case `ipAddressLeaseTime`:
                    value = configuration.dhcp.leases.pool.leaseSeconds;
                    break;
                case `rebindingTimeValue`:
                    value = Math.round(configuration.dhcp.leases.pool.leaseSeconds * 0.875);
                    break;
                case `renewalTimeValue`:
                    value = Math.round(configuration.dhcp.leases.pool.leaseSeconds * 0.75);
                    break;
                case `routerOption`:
                    value = configuration.dhcp.routers;
                    break;
                case `serverIdentifier`:
                    value = this.siaddr;
                    break;
                case `subnetMask`:
                    value = configuration.dhcp.leases.pool.networkMask;
                    break;
            }

            if (value !== undefined)
                options[dhcpOption.propertyName] = value;
        });

        this.options = options;

    }

    Parse(jsObject) {
        for (let prop in jsObject)
            switch (prop) {
                case `isDhcpMessage`:
                    break;

                default:
                    this[prop] = jsObject[prop];
            }
    }

    toString(format = `hex`) {
        return _bufferMessage.get(this).toString(format);
    }

    toJSON() {
        return {
            op: this.op,
            htype: this.htype,
            hlen: this.hlen,
            hops: this.hops,
            xid: this.xid,
            secs: this.secs,
            flags: this.flags,
            ciaddr: this.ciaddr,
            yiaddr: this.yiaddr,
            siaddr: this.siaddr,
            giaddr: this.giaddr,
            chaddr: this.chaddr,
            sname: this.sname,
            file: this.file,
            magicCookie: this.magicCookie,
            isDhcpMessage: this.isDhcpMessage,
            options: this.options,
        };
    }
}

module.exports.DHCPMessage = Message;
