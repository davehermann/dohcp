// Application modules
const { ParseOptions } = require(`./rfc2132`),
    { MACAddressFromHex, ReadString, ReadUInt8, ReadUInt16, ReadUInt32, ReadIpAddress } = require(`./utilities`),
    { Error } = require(`../logging`);

let _op = new WeakMap(),
    _htype = new WeakMap(),
    _hlen = new WeakMap(),
    _hops = new WeakMap(),
    _xid = new WeakMap(),
    _secs = new WeakMap(),
    _flags = new WeakMap(),
    _ciaddr = new WeakMap(),
    _yiaddr = new WeakMap(),
    _siaddr = new WeakMap(),
    _giaddr = new WeakMap(),
    _chaddr = new WeakMap(),
    _sname = new WeakMap(),
    _file = new WeakMap(),
    _magicCookie = new WeakMap(),
    _options = new WeakMap();

const MAGIC_COOKIE = [99, 130, 83, 99];

class Message {
    constructor() {}

    // Request or reply
    get op() { return _op.get(this); }
    set op(val) { _op.set(this, val); }

    // Hardware address type (1 for ethernet)
    get htype() { return _htype.get(this); }
    set htype(val) { _htype.set(this, val); }

    // Hardware address length (for identifier [MAC address for ethernet])
    get hlen() { return _hlen.get(this); }
    set hlen(val) { _hlen.set(this, val); }

    // Number of hops for BOOTP message (0 for direct from client)
    get hops() { return _hops.get(this); }
    set hops(val) { _hops.set(this, val); }

    // Unique identifier generated by client
    get xid() { return _xid.get(this); }
    set xid(val) { _xid.set(this, val); }

    // Client-generated seconds elapsed since client began address acquisition or renewal process
    get secs() { return _secs.get(this); }
    set secs(val) { _secs.set(this, val); }

    // Broadcast flag, most of which is reserved for future usage
    get flags() { return _flags.get(this); }
    set flags(val) { _flags.set(this, val); }

    // Client existing IP - Only non-zero for clients in BOUND/RENEW/REBINDING state
    get ciaddr() { return _ciaddr.get(this); }
    set ciaddr(val) { _ciaddr.set(this, val); }

    // [Y]our (server-assigned to client) IP address
    get yiaddr() { return _yiaddr.get(this); }
    set yiaddr(val) { _yiaddr.set(this, val); }

    // IP of the next server to use, in DHCPOFFER and DHCPACK
    get siaddr() { return _siaddr.get(this); }
    set siaddr(val) { _siaddr.set(this, val); }

    // Relay agent IP address (Used for booting via a relay)
    get giaddr() { return _giaddr.get(this); }
    set giaddr(val) { _giaddr.set(this, val); }

    // Client hardware address (e.g. Ethernet MAC)
    get chaddr() { return _chaddr.get(this); }
    set chaddr(val) { _chaddr.set(this, val); }

    // Server host name (optional)
    get sname() { return _sname.get(this); }
    set sname(val) { _sname.set(this, val); }

    // Boot file name: "generic" or null in DHCPDISCOVER; fully qualified directory-path in DHCPOFFER
    get file() { return _file.get(this); }
    set file(val) { _file.set(this, val); }

    // Magic cookie is defined in the RFC for beginning the options field
    // It is always 99, 130, 83 and 99
    // This formalizes the options as DHCP as opposed to underlying BOOTP vendor codes
    get isDhcpMessage() {
        let isDhcp = true;
        MAGIC_COOKIE.forEach((value, idx) => {
            if (value !== this.magicCookie[idx])
                isDhcp = false;
        });

        return isDhcp && (this.magicCookie.length == MAGIC_COOKIE.length);
    }
    get magicCookie() { return _magicCookie.get(this); }
    set magicCookie(val) { _magicCookie.set(this, val); }

    // DHCP Options
    get options() { return _options.get(this); }
    set options(val) { _options.set(this, val); }

    _readHardwareAddress(buf, offset, type, lengthInOctets) {
        let address;
        // The hardware address slot is 16 octets long
        ({ value: address, offset } = ReadString(buf, offset, 16, `hex`));

        // This is hardcoded to expect MAC addresses
        switch (type) {
            case 1:
                address = MACAddressFromHex(address.substr(0, lengthInOctets * 2));
                break;

            default:
                throw new Error(`Expected hardware address type of 1, but received ${type}`);
        }

        return { value: address, offset };
    }
    _readMagicCookie(buf, offset) {
        let vendorIdCookie = [];
        for (let idx = 0; idx < 4; idx++) {
            let value;
            ({ value, offset } = ReadUInt8(buf, offset));
            vendorIdCookie.push(value);
        }

        return { value: vendorIdCookie, offset };
    }

    Decode(messageBuffer) {
        // Specify an offset object that can be automatically adjusted by the read function
        // let offset = { offset: 0 };
        let offset = 0;

        ({ value: this.op, offset } = ReadUInt8(messageBuffer, offset));
        ({ value: this.htype, offset } = ReadUInt8(messageBuffer, offset));
        ({ value: this.hlen, offset } = ReadUInt8(messageBuffer, offset));
        ({ value: this.hops, offset } = ReadUInt8(messageBuffer, offset));
        ({ value: this.xid, offset } = ReadUInt32(messageBuffer, offset));
        ({ value: this.secs, offset } = ReadUInt16(messageBuffer, offset));
        ({ value: this.flags, offset } = ReadUInt16(messageBuffer, offset));
        ({ value: this.ciaddr, offset } = ReadIpAddress(messageBuffer, offset));
        ({ value: this.yiaddr, offset } = ReadIpAddress(messageBuffer, offset));
        ({ value: this.siaddr, offset } = ReadIpAddress(messageBuffer, offset));
        ({ value: this.giaddr, offset } = ReadIpAddress(messageBuffer, offset));
        ({ value: this.chaddr, offset } = this._readHardwareAddress(messageBuffer, offset, this.htype, this.hlen));
        ({ value: this.sname, offset } = ReadString(messageBuffer, offset, 64));
        ({ value: this.file, offset } = ReadString(messageBuffer, offset, 128));
        ({ value: this.magicCookie, offset } = this._readMagicCookie(messageBuffer, offset));

        // As options are the last component of a message, we don't need the offset back
        this.options = ParseOptions(messageBuffer, offset);
    }

    Encode() {

    }

    toString() {

    }

    toJSON() {
        return {
            op: this.op,
            htype: this.htype,
            hlen: this.hlen,
            hops: this.hops,
            xid: this.xid,
            secs: this.secs,
            flags: this.flags,
            ciaddr: this.ciaddr,
            yiaddr: this.yiaddr,
            siaddr: this.siaddr,
            giaddr: this.giaddr,
            chaddr: this.chaddr,
            sname: this.sname,
            file: this.file,
            magicCookie: this.magicCookie,
            isDhcpMessage: this.isDhcpMessage,
            options: this.options,
        };
    }
}

module.exports.DHCPMessage = Message;
