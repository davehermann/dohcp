import { ReadUInt8, ReadUInt32, ReadUInt16, ReadIPAddress, ReadString, MACAddressFromHex } from "../utilities";
import { IReadBinaryValueToString } from "../../interfaces/server";

const MAGIC_COOKIE = Uint8Array.from([99, 130, 83, 99]);

/** Hardware address types */
enum hardwareTypes {
    ethernet = 1,
}

/** Operation types */
enum operationTypes {
    BOOTREQUEST = 1,
    BOOTREPLY = 2,
}

class Message {
    //#region Private properties

    /** Operation type: request or reply */
    private op: operationTypes;
    /** Is this DHCP message a reply */
    private set isReply (val: boolean) { this.op = (val ? operationTypes.BOOTREPLY : operationTypes.BOOTREQUEST); }

    /** Hardware address type (1 for ethernet) */
    private htype: hardwareTypes;

    /**
     * Hardware address identifier length
     *   - MAC address for ethernet
     */
    private hlen: number;

    /** Number of hops for BOOTP message (0 for direct from client) */
    private hops: number;

    /** Unique identifier generated by client */
    private xid: number;

    /** Client-generated seconds elapsed since client began address acquisition or renewal process */
    private secs: number;

    /** Broadcast flag, most of which is reserved for future usage */
    private flags: number;

    /** Client existing IP - Only non-zero for clients in BOUND/RENEW/REBINDING state */
    private ciaddr: string;

    /** [Y]our (server-assigned to client) IP address */
    private yiaddr: string;

    /** IP of the next server to use, in DHCPOFFER and DHCPACK */
    private siaddr: string;

    /** Relay agent IP address (Used for booting via a relay) */
    private giaddr: string;

    /** Client hardware address (e.g. Ethernet MAC) */
    private chaddr: string;

    /** Server host name (optional) */
    private sname: string;

    /**
     * Boot file name
     *   - "generic" or *null* in **DHCPDISCOVER**
     *   - fully qualified directory-path in **DHCPOFFER**
     */
    private file: string;

    /**
     * Magic cookie is defined in the RFC for beginning the options field
     *   - It's **always** [99, 130, 83, 99]
     */
    private magicCookie: Uint8Array;
    /** This formalizes the options as DHCP as opposed to underlying BOOTP vendor codes */
    private get isDhcpMessage(): boolean {
        let messageIsDHCP = !!this.magicCookie && (this.magicCookie.length == MAGIC_COOKIE.length);

        // Check the value against the Magic Cookie
        if (messageIsDHCP)
            MAGIC_COOKIE.forEach((value, idx) => {
                if (!!this.magicCookie && (value !== this.magicCookie[idx]))
                    messageIsDHCP = false;
            });

        return messageIsDHCP;
    }

    /** DHCP Options */
    private options: number;

    /** Binary version of the message */
    private binaryMessage: Uint8Array;

    //#endregion Private properties

    //#region Private methods

    private readHardwareAddress(message: Uint8Array, offset: number): IReadBinaryValueToString {
        const { value, offsetAfterRead } = ReadString(message, offset, 16, `hex`);
        let address: string;

        // This is hardcoded to expect MAC addresses
        switch (this.htype) {
            case hardwareTypes.ethernet:
                address = MACAddressFromHex(value.substr(0, this.hlen * 2));
                break;

            default:
                throw new Error(`Expected hardware address type of 1, but received ${this.htype}`);
        }

        return { value: address, offsetAfterRead };
    }

    private readMagicCookie(message: Uint8Array, offset: number) {
        const newOffset = offset + 4,
            vendorIdCookie = message.subarray(offset, newOffset);

        return { value: vendorIdCookie, offsetAfterRead: newOffset };
    }

    //#endregion Private methods

    //#region  Public methods

    public Decode(message: Uint8Array): void {
        // Set the initial offset, which will be modified on every read
        let offset = 0;

        ({ value: this.op, offsetAfterRead: offset } = ReadUInt8(message, offset));
        ({ value: this.htype, offsetAfterRead: offset } = ReadUInt8(message, offset));
        ({ value: this.hlen, offsetAfterRead: offset } = ReadUInt8(message, offset));
        ({ value: this.hops, offsetAfterRead: offset } = ReadUInt8(message, offset));
        ({ value: this.xid, offsetAfterRead: offset } = ReadUInt32(message, offset));
        ({ value: this.secs, offsetAfterRead: offset } = ReadUInt16(message, offset));
        ({ value: this.flags, offsetAfterRead: offset } = ReadUInt16(message, offset));
        ({ value: this.ciaddr, offsetAfterRead: offset } = ReadIPAddress(message, offset));
        ({ value: this.yiaddr, offsetAfterRead: offset } = ReadIPAddress(message, offset));
        ({ value: this.siaddr, offsetAfterRead: offset } = ReadIPAddress(message, offset));
        ({ value: this.giaddr, offsetAfterRead: offset } = ReadIPAddress(message, offset));
        ({ value: this.chaddr, offsetAfterRead: offset} = this.readHardwareAddress(message, offset));
        ({ value: this.sname, offsetAfterRead: offset } = ReadString(message, offset, 64));
        ({ value: this.file, offsetAfterRead: offset } = ReadString(message, offset, 128));
        ({ value: this.magicCookie, offsetAfterRead: offset } = this.readMagicCookie(message, offset));
    }


    public toJSON(): any {
        return {
            op: this.op,
            htype: this.htype,
            hlen: this.hlen,
            hops: this.hops,
            xid: this.xid,
            secs: this.secs,
            flags: this.flags,
            ciaddr: this.ciaddr,
            yiaddr: this.yiaddr,
            siaddr: this.siaddr,
            giaddr: this.giaddr,
            chaddr: this.chaddr,
            sname: this.sname,
            file: this.file,
            magicCookie: this.magicCookie,
            isDhcpMessage: this.isDhcpMessage,
            options: this.options,
        };
    }

    //#endregion Public methods
}

export {
    Message as DHCPMessage,
};
